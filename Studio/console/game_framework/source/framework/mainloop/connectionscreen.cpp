/*****************************************************************************
*
* File :     connectionscreen.cpp
*
* Notes : This file contains the behaviour code which is used to display the
* waiting to connect screen. The bulk of the code being in the LoadingScreen
* project.
*
*
*****************************************************************************
*
* This file is a product of Criterion Software Ltd.
*
* This file is provided as is with no warranties of any kind and is
* provided without any obligation on Criterion Software Ltd. or
* Canon Inc. to assist in its use or modification.
*
* Criterion Software Ltd. will not, under any
* circumstances, be liable for any lost revenue or other damages arising
* from the use of this file.
*
* Copyright (c) 2000 Criterion Software Ltd.
* All Rights Reserved.
*
* RenderWare is a trademark of Canon Inc.
*
*****************************************************************************/

#include "precomp.h"

//////////////////////////////////////////////////////////////////
//
// RenderWare Studio Includes
//
#include "connectionscreen.h"
#include "render.h"
#include "framework/core/macros/debugmacros.h"
#include "framework/toolkits/world/clevel.h"
#include "framework/core/memoryhandler/memoryprofile.h"

#define RWS_LOADING_SCREEN

#ifdef RWS_DESIGN
#ifdef RWS_LOADING_SCREEN
#include "../../../../../plugins/loading_screen/cloadingscreen.h"
#endif
#endif

namespace RWS
{
   namespace MainLoop
   {
      extern RwChar g_szWaitingMessage[128]; // defined in network.cpp
   }
   
   namespace 
   {
#if defined (RWS_DESIGN) && defined (RWS_LOADING_SCREEN)
      CLoadingScreen *g_SplashScreen; 
#endif
   }
   
   namespace ConnectionScreen
   {
#ifdef RWS_DESIGN

      /**
      *
      *  Construct a CRenderConnectionScreen object
      *
      */
      CRenderConnectionScreen::CRenderConnectionScreen() : InitCEventHandler(0)
      {
         RWS_FUNCTION("CRenderConnectionScreen::CRenderConnectionScreen");
         
         RegisterForAutoDelete();

#ifdef RWS_LOADING_SCREEN
         g_SplashScreen = ::RWS_NEW CLoadingScreen;
#endif
         
         LinkMsg(iMsgDoRender, "RwCamera*");


         // We don't want to profile while the title screen is being displayed as it will
         // cause the profile buffer to overrun due to the alloc/free generated by rendering
         // the waiting to connect text.
         //
         m_MemoryProfilingEnabled = RWS::MemoryProfile::Enable(FALSE);
         
         RWS_RETURNVOID();
      }
      
      /**
      *
      *  Destroy a CRenderConnectionScreen object
      *
      */
      CRenderConnectionScreen::~CRenderConnectionScreen()
      {
         RWS_FUNCTION("CRenderConnectionScreen::~CRenderConnectionScreen");
         
         UnLinkMsg(iMsgDoRender);
         
#ifdef RWS_LOADING_SCREEN
         delete g_SplashScreen;
#endif

         RWS::MemoryProfile::Enable(m_MemoryProfilingEnabled);

         RWS_RETURNVOID();
      }

      /**
      *
      *  Handle Events, iMsgDoRender
      *
      */
      void CRenderConnectionScreen::HandleEvents(CMsg &pMsg)
      {
         RWS_FUNCTION("CRenderConnectionScreen::HandleEvents");
         
         if (pMsg.Id == iMsgDoRender)
         {
            RwCamera *pRwCamera = reinterpret_cast<RwCamera*>(pMsg.pData);
            
            if (pRwCamera)
            {
#ifndef RWS_LOADING_SCREEN
               // Clear background and z buffer, must be done before RwCameraBeginUpdate
               //
               static const RwRGBA backgroundColor = {64, 64, 128, 255};
               
               RwCameraClear(pRwCamera, const_cast<RwRGBA*>(&backgroundColor),
                  rwCAMERACLEARSTENCIL | rwCAMERACLEARIMAGE | rwCAMERACLEARZ);
#endif
               
               // Display the waiting for connection text
               //
#ifdef RWS_DEBUGTOOLS
               {
                  static int count = 0;
                  RwChar buf[64];
                  
                  count ++;
                  
                  if (count == 80) count = 0;
                  
                  char buffer[4];
                  
                  int i;
                  
                  for (i = 0;i < (count / 20);i++)
                  {
                     buffer[i] = '.';
                  }
                  
                  buffer[i] = 0;
                  
                  rwsprintf(buf, "%s%s", MainLoop::g_szWaitingMessage, buffer);
                  
#ifdef RWS_LOADING_SCREEN
                  // Display Loading Screen
                  //
                  g_SplashScreen->Render(pRwCamera, buf);
#else
                  DebugTools::Printf(buf);
#endif // RWS_LOADING_SCREEN
               }
#endif // RWS_DEBUGTOOLS
            }
         }
         RWS_RETURNVOID();
      }
#endif // RWS_DESIGN
   }
}
